[{"content":"面向对象程序设计的三大支柱：封装、继承、多态\n类与对象 类为对象定义属性和行为，类是一个模板、蓝本、条约。\n对象代表现实世界的可以明确标识的一个实体。对象是类的实例化，一个类可以创建多个对象，创建的过程称为实例化，对象和实例经常可互换。\n对象的创建 使用关键字new 创建对象\n使用构造方法构造方法  构造方法必须和所在类名字相同 构造方法没有返回值类型，甚至连void都没有 构造方法是在创建一个对象时由new操作符调用的  如果用户没有定义构造方法，类会隐式的定义一个无参的构造方法，这个构造方法为默认构造方法\n使用this来调用构造方法 关键词this可以用于调用一个类的另一个构造方法\n访问对象的数据和方法 数据的访问和方法调用用点操作符( . )进行\n objectRefVar.dataField 引用对象的数据域 objectRefVar.method*(arguments) 调用对象的方法  封装 封装 ，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。封装可以保证类的数据安全，便于维护和修改数据。\ngetter和setter 为了访问私有数据域，提供一个获取方法返回数据域的值，这个方法为getter方法，也叫访问器。\npublic returnType getPropertyName()\npublic boolean isPropertyName() \n为了更新数据域，提供一个设置方法给数据域设置新的值，这个方法为setter方法，也叫修改器。\npublic void setPropertyName()\n继承 类之间的关系通常有关联、聚合、组合、继承\n什么是继承 继承是在定义一个通用的类后，无需重新编写就可以使用这个类的一些功能，并可以在此类上进行扩展。\n被继承定义的类为“基类”、”父类“、”超类“\n通过继承的类为”子类“、”派生类“\n继承用关键字extends来说明\npublic class Circle extends GeometricObject 表示Circle继承于GeometricObject类\n注意点\n 子类不是父类的子集，一个子类比父类的有更多的信息和方法 父类的私有数据域在该类之外不可访问 Java之中是不允许多重继承  子类中的运用  使用super（）或super（arguments)可以调用父类的构造方法 使用super.方法名（arguments)可调用普通方法  方法的重写和重载 重写 子类从父类中继承方法。有时，子类需要修改父类中定义的方法的实现，这称为方法重写。用@Override来标注\npublic class Circle extends GeometricObject{ @Override public String toString() { return super.toString() + \u0026#34;\\nradius is \u0026#34; + radius; } } 注意\n 重写方法和被重写方法具有一样的签名 只有当实例方法可访问时，才可以被重写 静态方法不可以被重写，定义在父类中的静态方法在子类中被重写定义，父类中的静态方法将会被隐藏，可以通过”父类名.静态方法名“ 来调用隐藏的静态方法。  重载 重载是使用同样的名字但是有不同的签名来定义多个方法，\n注意\n 重载可以发生在同一个类中，也可以发生具有继承关系的不同类中 重载有同样名字，不同的参数列表  多态 多态，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。\n多态意味着父类型的变量可以引用子类型的对象\n多态的优点  消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性  多态存在的三个必要条件  继承 重写 父类引用指向子类对象  ","description":"","id":2,"section":"posts","tags":["Java"],"title":"面向对象三大特性","uri":"https://shijin.fun/posts/encapsulation-inheritance-polymorphism/"},{"content":"1、 面向对象和面向过程的区别 ​ 以前学习C语言是，用的是面向过程的开发方法，就是把整个需求过程给分析出来，列出步骤，根据每一个步骤啊，写一个对应函数完成某一项功能，需要用的时候一个个调用就行。这是一种常用的思维方式，平时用的也比较多。\n​ 而现在学习的Java语言是一门面向对象的语言，他是把每一个问题解决的方法分解为各个对象，每个对象有各自的功能，需要时就调用。面向过程的数据和动作是分开的，而面向对象的数据和动作是一起定义在对象中的。面向对象的一种编程方式更加的模拟了现实世界。\n​ 举个例子，一个大型的游戏，是一个多人对抗的游戏，游戏中有很多人物，每个人物有共同的特征也有各个人物的功能特点，如果运用面向过程的方法就会使得游戏很困难的运行，但采用面向对象的方式就会很简单，把每个人物的数据和方法耦合在一起，每个人物可以实例化一个对象，并定义自己的行为，这样使得重用性得到大大的提高，游戏设计也变得简单。\n2、面向对象和面向过程的优缺点 面向对象： 优点： ​\t面向对象的三大特性：封装、继承、多态\n 有着三个特性使得程序易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；  \r同时结构也清晰，模块化，结构化。  \r后期的维护也变得简单  \r缺点：  开销大，每次调用对象都要实例化。当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。  \r 性能低，面向对象的抽象层次较高，对内存和计算时间都会增加开支。  \r面向过程 优点：  流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。  \r效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。一般单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素  \r缺点：  设计时注重于方法，对方法设计优化程度要求高  \r 代码重用性低，扩展能力差，  \r 后期维护难度比较大。  \r","description":"","id":3,"section":"posts","tags":["Java"],"title":"面向对象的思考","uri":"https://shijin.fun/posts/object-oriented-thinking/"},{"content":"1.什么是正则表达式 ​ 正则表达式（regular expression）regex 是一个字符串，用于描述匹配一个字符串集的模式。\n​ 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。\n​ 正则表达式可以用来搜索、编辑或处理文本。\n​ 正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。\n2.Java中的regex Java.util.regex包有三个类：\n  Pattern 类：\npattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n  Matcher 类：\nMatcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\n  PatternSyntaxException：\nPatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n  3.编写规则 常见匹配符号    正则表达式 匹配     . 匹配所有单个字符，除了换行符（Linux 中换行是 \\n，Windows 中换行是 \\r\\n）   ^regex 正则必须匹配字符串开头   regex$ 正则必须匹配字符串结尾   [abc] 复选集定义，匹配字母 a 或 b 或 c   [abc][vz] 复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z   [^abc] 当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c   [a-d1-7] 范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1   XZ 匹配 X 后直接跟着 Z   X|Z 匹配 X 或 Z       \\d 匹配一个数字，是 [0-9] 的简写   \\D 匹配一个非数字，是 [^0-9] 的简写   \\s 匹配一个空格，是 [ \\t\\n\\x0b\\r\\f] 的简写   \\S 匹配一个非空格   \\w 匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写   \\W 匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\\w]       * 匹配 \u0026gt;=0 个，是 {0,} 的简写   + 匹配 \u0026gt;=1 个，是 {1,} 的简写   ? 匹配 1 个或 0 个，是 {0,1} 的简写   {X} 只匹配 X 个字符   {X,Y} 匹配 \u0026gt;=X 且 \u0026lt;=Y 个   *? 如果 ? 是限定符 * 或 + 或 ? 或 {} 后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式        分组 小括号 () 可以达到对正则表达式进行分组的效果。\n指定正则表达式的模式  (?i) 使正则忽略大小写。 (?s) 表示单行模式（\u0026ldquo;single line mode\u0026rdquo;）使正则的 . 匹配所有字符，包括换行符。 (?m) 表示多行模式（\u0026ldquo;multi-line mode\u0026rdquo;），使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。  Java中的反斜杠 反斜杠 \\ 在 Java 中表示转义字符，这意味着 \\ 在 Java 拥有预定义的含义。\n这里例举两个特别重要的用法：\n 在匹配 . 或 { 或 [ 或 ( 或 ? 或 $ 或 ^ 或 * 这些特殊字符时，需要在前面加上 \\\\，比如匹配 . 时，Java 中要写为 \\\\.，但对于正则表达式来说就是 \\.。 在匹配 \\ 时，Java 中要写为 \\\\\\\\，但对于正则表达式来说就是 \\\\。  注意：Java 中的正则表达式字符串有两层含义，首先 Java 字符串转义出符合正则表达式语法的字符串，然后再由转义后的正则表达式进行模式匹配。\n4.实例   (aaa){5}，匹配’aaa’5次\n  \u0026ldquo;food|f\u0026quot;匹配的是foo（d或f），而\u0026rdquo;(food)|f\u0026quot;匹配的是food或f\n  数值 ： ^[+-]?\\d+(.\\d+)?$\n  密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n  中文 ： [\\u4e00-\\u9fa5]\n  E-mail ：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$\n​ s.matches(\u0026ldquo;^[+\\-]?\\d*(\\.\\d+)?$\u0026rdquo;)\n  Java内置的字符串正则处理方法 在 Java 中有四个内置的运行正则表达式的方法，分别是 matches()、split())、replaceFirst()、replaceAll()。注意 replace() 方法不支持正则表达式。\n   方法 方法     s.matches(\u0026quot;regex\u0026quot;) 当仅且当正则匹配整个字符串时返回 true   s.split(\u0026quot;regex\u0026quot;) 按匹配的正则表达式切片字符串   s.replaceFirst(\u0026quot;regex\u0026quot;, \u0026quot;replacement\u0026quot;) 替换首次匹配的字符串片段   s.replaceAll(\u0026quot;regex\u0026quot;, \u0026quot;replacement\u0026quot;) 替换所有匹配的字符    示例代码 public class RegexTest { public static void main(String[] args) { System.out.println(\u0026#34;wxj\u0026#34;.matches(\u0026#34;wxj\u0026#34;)); System.out.println(\u0026#34;----------\u0026#34;); String[] array = \u0026#34;w x j\u0026#34;.split(\u0026#34;\\\\s\u0026#34;); for (String item : array) { System.out.println(item); } System.out.println(\u0026#34;----------\u0026#34;); System.out.println(\u0026#34;w x j\u0026#34;.replaceFirst(\u0026#34;\\\\s\u0026#34;, \u0026#34;-\u0026#34;)); System.out.println(\u0026#34;----------\u0026#34;); System.out.println(\u0026#34;w x j\u0026#34;.replaceAll(\u0026#34;\\\\s\u0026#34;, \u0026#34;-\u0026#34;)); } } true ---------- w x j ---------- w-x j ---------- w-x-j 模式与匹配 Java 中使用正则表达式需要用到两个类，分别为 java.util.regex.Pattern 和 java.util.regex.Matcher。\n  通过正则表达式创建模式对象 Pattern。\n  通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。\n  通过匹配对象 Matcher，根据正则表达式操作字符串。\n  // 数字的匹配  import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexTest { public static void main(String[] args) { String str = \u0026#34;1990\\n2010\\n2017\u0026#34;; // 这里应用了 (?m) 的多行匹配模式，只为方便我们测试输出  // \u0026#34;^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$\u0026#34; 为判断 1990-2017 正确的正则表达式  Pattern pattern = Pattern.compile(\u0026#34;(?m)^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$\u0026#34;); Matcher matcher = pattern.matcher(str); while (matcher.find()) { System.out.println(matcher.group()); } } } 1990 2010 2017 // 图片的匹配  import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexTest { public static void main(String[] args) { String str = \u0026#34;\u0026lt;img src=\u0026#39;aaa.jpg\u0026#39; /\u0026gt;\u0026lt;img src=bbb.png/\u0026gt;\u0026lt;img src=\\\u0026#34;ccc.png\\\u0026#34;/\u0026gt;\u0026#34; + \u0026#34;\u0026lt;img src=\u0026#39;ddd.exe\u0026#39;/\u0026gt;\u0026lt;img src=\u0026#39;eee.jpn\u0026#39;/\u0026gt;\u0026#34;; // 这里我们考虑了一些不规范的 img 标签写法，比如：空格、引号  Pattern pattern = Pattern.compile(\u0026#34;\u0026lt;img\\\\s+src=(?:[\u0026#39;\\\u0026#34;])?(?\u0026lt;src\u0026gt;\\\\w+.(jpg|png))(?:[\u0026#39;\\\u0026#34;])?\\\\s*/\u0026gt;\u0026#34;); Matcher matcher = pattern.matcher(str); while (matcher.find()) { System.out.println(matcher.group(\u0026#34;src\u0026#34;)); } } } aaa.jpg bbb.png ccc.png \u0026mdash;\u0026mdash;参考吴仙杰的java正则表达式详解\n五、总结 正则表达式在日常的编程中使用还是比较多的，一时间可能学不会，但是在实践中边学习边用是比较好的。\n","description":"","id":4,"section":"posts","tags":["Regex","Java"],"title":"Java正则表达式","uri":"https://shijin.fun/posts/java-regex/"},{"content":"前几天完成了hexo向hugo的迁移，记录一下过程。\n1. 原因  hugo比hexo更快，文章多后就会有差异 hugo是用go写的，正好我正准备学习go，所以就当学习  2. hexo和hugo的差异 在hugo的官网上hugo是这样介绍的\nThe world’s fastest framework for building websites\n确实是这样，hugo不管在安装和使用上都要比hexo简单一点，更容易上手，hugo与hexo类似，但比hexo更高效、简洁、扩展性强。\n在安装上 hugo只需要一个二进制文件即可，而hexo必须安装一些其他依赖。\n更多hugo信息请看hugo官网https://gohugo.io/\n3.hugo的使用 一、首先你的电脑必须安装 + Git\r+ Go(https://golang.google.cn/)\r 二、源码安装   到GitHub上下载关于自己电脑配置的版本https://github.com/gohugoio/hugo/releases，下载\n  在自己电脑下的任意位置，创建一个文件目录，创建一个bin文件来，把文件解压\n ~/Hugo $ tree -L 1\r. ├── bin/ ├── hugo.exe\r├── .. ├── sites/ # 存放网址\r  把带有Hugo.exe的目录添加到环境变量\n  使用hugo version检查安装是否成功\n  三、创建站点 hugo new site blog 创建一个名为blog的站点\n~/blog $ tree -L 1 . # 说明 Hexo ├── archetypes/ # 文章模板 scaffolds/ ├── assets/ # Hugo 管道 ├── config.toml # 配置文件 _config.yml ├── content/ # 文章目录 source/_posts/ ├── data/ # Hugo 数据文件 source/_data/ ├── layouts/ # 布局模板 ├── public/ # 生成的静态文件 public/ ├── resources/ # Hugo 缓存 ├── static/ # 网站的静态文件 source/ └── themes/ # 主题目录 themes/ 添加一个主题 在官方网站上有很多种主题可以选择，挑一个自己喜欢的主题\n然后把主题里的exampleSite里的文件复制在根目录\ncd blog;\\\rgit init;\\\rgit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke;\\\r# Edit your config.toml configuration file\r# and add the Ananke theme.\recho 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\r添加一篇新文章 hugo new posts/my-first-post.md\r查看运行效果 hugo server\r四、主题配置 主题配置在config下的.toml下的文件中配置，详细配置就不说了，根据自己的情况配置，更多的主题修改可在layout里修改\n五、配置GitHub Pages 这部分网上教程非常多，首先在 GitHub 上创建一个 Repository，命名为 username.github.io\n把 config.toml 的 basaeURL 修改为 https://usrname.github.io/\n然后进入你的 public 目录按照正常 Git 命令操作即可\n$ cd public\r$ git init\r$ git remote add origin https://github.com/username/username.github.io.git\r$ git add -A\r$ git commit -m \u0026quot;first commit\u0026quot;\r$ git push -u origin master\r第一次初始化时可能会叫配置用户名和密码：\ngit config --global user.name \u0026quot;xxx\u0026quot;\rgit config --global user.email \u0026quot;xxx@xxx.com\u0026quot;\r之后更新文章并生成好静态页面以后，就可以使用 Git push 来同步了\n$ cd public\r$ git add .\r$ git commit -m \u0026quot;add blog post\u0026quot;\r$ git push\r关于 Git 的使用说明，可以参考网络上的一大堆教程，这里不再重复。\n编写自动化脚本 在根目录下创建deploy.sh，输入如下：\n#!/bin/sh\r# If a command fails then the deploy stops\rset -e\rprintf \u0026quot;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026quot;\r# Build the project.\rhugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;`\r# Go To Public folder\rcd public\r# Add changes to git.\rgit add .\r# Commit changes.\rmsg=\u0026quot;rebuilding site $(date)\u0026quot;\rif [ -n \u0026quot;$*\u0026quot; ]; then\rmsg=\u0026quot;$*\u0026quot;\rfi\rgit commit -m \u0026quot;$msg\u0026quot;\r# Push source and build repos.\rgit push origin master\r此后，编写文章后，双击脚本运行自动上次到GitHub。\n4. 下一步计划 采用阿里云OSS+CDN加速+全站https\n让网站飞起来🍻\n","description":"","id":5,"section":"posts","tags":["Hugo"],"title":"Hexo迁移到Hugo","uri":"https://shijin.fun/posts/hexo-move-hugo/"},{"content":"什么是Docker ​\tDocker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。\n​\tDocker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。\n​\tDocker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。\n​\t在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。\n为什么选择Docker?\n（1）上手快。\n​\t用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。\n 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。\n（2）职责的逻辑分类\n​\t使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”\n（3）快速高效的开发生命周期\n​\tDocker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）\n（4）鼓励使用面向服务的架构\n​\tDocker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）\n一、更新软件 为避免安装软件时，系统的一些包或软件版本过低，我们拿到一台新服务器时会跟新一下系统软件\nUbuntu 更新软件\n  sudo apt-get update;\n  sudo apt-get upgrade\n  centos更新软件\n sudo yum update  以下在Ubuntu演示： 安装docker  sudo apt-get install docker.io 查看版本信息 docker -v  把docker添加到用户组，以便当前用户使用docker命令\n sudo usermod -aG docker $USER  重新登录\ndocker info 查看信息\n设置docker镜像仓库源 dockers默认仓库在国外，比较慢，换回国内。\nUbuntu 的是在默认路径，centos有些不是在默认路径\n sudo vi /etc/docker/daemon.json  添加信息\n{ \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://registry.docker-cn.com\u0026quot;] } 安装docker-compose  sudo pip install docker-compose -i http://pypi.douban.com/simple \u0026ndash;trusted-host pypi.douban.com  查看版本\n docker-compose -v  官方安装文档 文档地址：  https://docs.docker.com/install/  官方 Dockerfile  nginx: https://github.com/nginxinc/docker-nginx mysql: https://github.com/docker-library/mysql python: https://github.com/docker-library/python redis: https://github.com/docker-library/redis  镜像 Tag 查询 https://registry.hub.docker.com/\n","description":"","id":6,"section":"posts","tags":["Docker"],"title":"Docker的安装","uri":"https://shijin.fun/posts/install-docker/"},{"content":"1.引言 平时经常处理一些Excel文件，小的文件直接用Excel处理还行，大的文件，可以试着用python来处理，相对比较方便，而且python易学，代码简单。\n2.第三方库 - xlrd 读 - xlwt 写 3.代码 import xlrd 读取 file = \u0026#39;test3.xlsx\u0026#39; def read_excel(): wb = xlrd.open_workbook(filename=file)#打开文件 print(wb.sheet_names())#获取所有表格名字 sheet1 = wb.sheet_by_index(0)#通过索引获取表格 sheet2 = wb.sheet_by_name(\u0026#39;年级\u0026#39;)#通过名字获取表格 print(sheet1,sheet2) print(sheet1.name,sheet1.nrows,sheet1.ncols) rows = sheet1.row_values(2)#获取行内容 cols = sheet1.col_values(3)#获取列内容 print(rows) print(cols) print(sheet1.cell(1,0).value)#获取表格里的内容，三种方式 print(sheet1.cell_value(1,0)) print(sheet1.row(1)[0].value) 合并表格：\nmerged_cells()用法，merged_cells返回的这四个参数的含义是：(row,row_range,col,col_range)\nimport xlwt #设置表格样式 def set_style(name,height,bold=False): style = xlwt.XFStyle() font = xlwt.Font() font.name = name font.bold = bold font.color_index = 4 font.height = height style.font = font return style #写Excel def write_excel(): f = xlwt.Workbook() sheet1 = f.add_sheet(\u0026#39;学生\u0026#39;,cell_overwrite_ok=True) row0 = [\u0026#34;姓名\u0026#34;,\u0026#34;年龄\u0026#34;,\u0026#34;出生日期\u0026#34;,\u0026#34;爱好\u0026#34;] colum0 = [\u0026#34;张三\u0026#34;,\u0026#34;李四\u0026#34;,\u0026#34;练习Python\u0026#34;,\u0026#34;小明\u0026#34;,\u0026#34;小红\u0026#34;,\u0026#34;无名\u0026#34;] #写第一行 for i in range(0,len(row0)): sheet1.write(0,i,row0[i],set_style(\u0026#39;Times New Roman\u0026#39;,220,True)) #写第一列 for i in range(0,len(colum0)): sheet1.write(i+1,0,colum0[i],set_style(\u0026#39;Times New Roman\u0026#39;,220,True)) sheet1.write(1,3,\u0026#39;2006/12/12\u0026#39;) sheet1.write_merge(6,6,1,3,\u0026#39;未知\u0026#39;)#合并行单元格 sheet1.write_merge(1,2,3,3,\u0026#39;打游戏\u0026#39;)#合并列单元格 sheet1.write_merge(4,5,3,3,\u0026#39;打篮球\u0026#39;) f.save(\u0026#39;test.xls\u0026#39;) 常用时间库\nimport time startime = time.strftime(\u0026#34;%Y-%m-%d%H:%M:%S\u0026#34;, time.localtime()) # 获取系统当前时间并格式化为格式 print(time.strftime(\u0026#34;%Y-%m-%d%H:%M:%S\u0026#34;, time.localtime()) + \u0026#39; ***\u0026#39;) # “实时+***” ","description":"","id":7,"section":"posts","tags":["Excel","Python"],"title":"Python简单处理excel","uri":"https://shijin.fun/posts/python-simple-excel/"},{"content":"Markdown是一种标记语言，语法简单，易阅读易编写，可以让用户完全脱离鼠标写出样式丰富的文档，广受程序员喜爱，目前许多网站都已经支持通过Markdown语法来写文章或者发表评论。\n   元素 Markdown语法     标题 # 标题1\n## h2\n### h3   加粗 **文字加粗**   引用 \u0026gt; 引用文字   有序列表 1. 第一项\n2. 第二项\n3. 第三项   无序列表 - 第一项\n- 第二项\n- 第三项   链接 [链接](url)   图片 ![图片](image.jpg)   水平线 ---   代码 `code`   代码块 ```code snippet```    ","description":"","id":8,"section":"posts","tags":["Markdown"],"title":"Markdown的简单使用","uri":"https://shijin.fun/posts/markdown-use/"},{"content":"在国庆前一个星期，我准备自己写一个博客网站，于是在网上查了一下怎么写才好，本来想自己一步步的来，但是看了一下网上一些比较好的博客网站，发现他们都是基于某个框架搭建的，于是我也就选了hexo+github来搭建我的博客网站。\n为什么要搭建这个博客网站了？\n一是兴趣来了，想做一个来玩玩；\n二是为了能促进自己学习嘛，虽然不一定写博客，哈哈。\n1. 过程 我呢是根据网上的教程一步步来构建的，中途也是遇到了一些小问题，但在网上都能找到解决的办法，所以，只要自己愿意去做，没有困难可以阻挡自己前进的。\n大概步骤： + 安装Node.js\r+ 添加国内镜像源\r+ 安装Git\r+ 注册Github账号\r+ 创建一个以自己账户名.io的仓库\r+ 安装Hexo\r+ 个性化设置（主题下载与配置）\r+ 连接Github与本地，上传代码\r+ 写文章、发布文章\r+ 绑定域名（可选）\r 具体过程呢我就不说了网上教程多的是\n附一个比较好的教程链接吧。\nHexo 搭建个人博客系列：基础建站篇\n过程困难点  一安装各种东西，新手可能觉得有些问题 没接触过这种代码可能不知所措，难以下手 一些小bug。。。  我所遇到的困难呢，主要是配置ssh。\n由于我一开始git配置的是gitee,但是当我把git配置到GitHub上后我原来的配置就不能用了，把我折腾了半天，最后在网上找到教程终于弄好了。主要是把ssh配置两个文件，一个gitee,一个GitHub。\n解决方法：\n关于域名 在GitHub上搭建好博客网站后，如果不喜欢自己的域名，可以自己买一个域名来代替原来的域名，而且不需要备案，在阿里云和腾讯云都可以买。域名解析简单。\n配置域名步骤：\n 在命令行里ping一下GitHub分配给自己的网址 在域名控制台解析里添加两条记录  @\tA\t默认\tIP地址 10 分钟\rwww\tA\t默认\tIP地址 10 分钟\r 在自己的source文件夹下创建一个CNAME文件，文件里写如自己的域名 同步GitHub仓库，然后就可以愉快的用自己域名了  2. 总结 国庆节忙活了好几天，终于把一个基本的博客网站个弄好了，还是有很多的不足之处，慢慢来嘛，万事开头难，现在只需要后期完善，把它弄得好看就行了。不过我也得好好学习下那些技术，才能把它完全弄明白。\n","description":"","id":9,"section":"posts","tags":["Hexo"],"title":"Hexo+GitHub搭建博客","uri":"https://shijin.fun/posts/hexo-github/"},{"content":"资源链接\r --\r\r编程基础\n提取码：t4ig\r\r\r --\r\rPython优质书籍\n提取码：2uae\r\r\r\r\r#\n#\r\r --\r\r","description":"一些好书资源链接","id":10,"section":"","tags":null,"title":"书籍推荐","uri":"https://shijin.fun/books/"},{"content":"友情链接\r --\rSharpFactory\nSharpFactory 官网\r\r\r --\rxurenda | 朽者，然也\n一个全能大佬\r\r\r --\r陈煜峰个人博客\n一位云计算工程师\r\r\r\r","description":"云原生实验室的友情链接","id":11,"section":"","tags":null,"title":"我的朋友们","uri":"https://shijin.fun/friends/"},{"content":"一只特立独行的猴子\r笔名世今\r热爱生活\r迷恋诗和远方\r努力拼搏，坚持不懈\r极简主义者\r","description":"博主的个人简介","id":12,"section":"","tags":null,"title":"关于博主","uri":"https://shijin.fun/about/"}]